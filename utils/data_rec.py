"""
This script runs reconstruction on all .h5 files in a directory.
It uses the tomopy library to perform the reconstruction.

"""

import os
import subprocess
import argparse
from concurrent.futures import ThreadPoolExecutor, as_completed
import logging
import shutil
import numpy as np
import algotom.io.loadersaver as losa
import yaml
from tqdm import tqdm
import algotom.io.loadersaver as losa
import algotom.prep.correction as corr
import algotom.prep.calculation as calc
import algotom.rec.reconstruction as rec
import algotom.util.utility as util

logging.basicConfig(level=logging.INFO)
import random


def load_center_rotations(file_path):
    base = os.path.dirname(file_path)
    yml_file = os.path.join(base, "extra_params.yaml")
    with open(yml_file, "r") as file:
        data = yaml.safe_load(file)
    return data


def extract_tomo_id(file_path):
    base_name = os.path.basename(file_path)
    tomo_id = base_name.split("_")[1].split(".")[0]
    return tomo_id


def pixel_offset(rot):
    """
    Pixel offset to generate wrong center of rotation
    """
    if random.choice([True, False]):
        return rot + 100
    else:
        return rot - 100


def run_reconstruction_file(file_path, data_type):
    """
    Creates reconstructions for a single file.

    Args:
        file_path (str): The path to the .h5 file to reconstruct.
        data_type (str): The type for reconstruction to generate artifacts.
                currently supports:
                with-ring : artifacts generated by keeping ring artifacts(without correction method).
                no-ring : artifacts generated by removing ring artifacts(fw correction method).
                bad-center : artifacts generated by providing a wrong center of rotation
    """

    rec_dir = file_path.replace(".h5", "_rec")

    if os.path.exists(rec_dir):
        shutil.rmtree(rec_dir)
    os.makedirs(rec_dir)

    ## This loads the center of rotation from the yaml file
    center_rotations = load_center_rotations(file_path)
    tomo_id = extract_tomo_id(file_path)

    rot_center = center_rotations.get(os.path.basename(file_path), {}).get(
        "rotation-axis"
    )

    if data_type == "bad-center":
        if rot_center is None:
            logging.info(
                f"Rotation center not found for {file_path}. Selecting a random center..."
            )
            ## an alternative if it to calculate the center of rotation(see documentation of tomopy)
            rot_center = random.uniform(1.0, 1500.0)
            logging.info(f"Calculated rotation center: {rot_center}")
        else:
            rot_center = pixel_offset(rot_center)

    base_command = "tomopy recon --rotation-axis-auto manual --reconstruction-type full --nsino-per-chunk 1024 --fix-nan-and-inf True \
    --remove-stripe-method fw --rotation-axis <rotation_axis> --file-name <file_path>"

    command = base_command.replace("<file_path>", file_path).replace(
        "<rotation_axis>", str(rot_center)
    )

    command = command.strip().split()

    if data_type == "with-ring":
        command = [arg.replace("fw", "none") for arg in command]

    logging.info(
        f"Running reconstruction on {file_path} with command: {' '.join(command)}"
    )
    print(f"Running reconstruction on {file_path}")
    subprocess.run(command)


def run_algotom(file_path, data_type) -> None:
    """
        Run reconstruction using algotom library this is for .hdfs and .nxs files.
        used the algotom library to perform the reconstruction.

        Full code is found here: https://github.com/algotom/algotom/tree/master/examples

    Args:
        file_path (str): The path to the .hdfs or .nxs file to reconstruct.
        data_type (str): The type for reconstruction to generate artifacts.
                currently supports:
                with-ring : artifacts generated by keeping ring artifacts(without correction method).
                no-ring : artifacts generated by removing ring artifacts(fw correction method).
                bad-center : artifacts generated by providing a wrong center of rotation

    """

    output_base = file_path.replace(".hdfs", "_rec").replace(".nxs", "_rec")
    rec_dir = file_path.replace(".hdfs", "_rec").replace(".nxs", "_rec")

    # Provide path to datasets in the nxs file.
    # data_key = "/entry1/tomo_entry/data/data"
    # image_key = "/entry1/tomo_entry/instrument/detector/image_key"
    # angle_key = "/entry1/tomo_entry/data/rotation_angle"

    keys, shapes, dtypes = losa.get_hdf_information(file_path)
    for i, key in enumerate(keys):
        print(
            "Key :-> {0} | Shape :-> {1} | Type :-> {2}".format(
                key, shapes[i], dtypes[i]
            )
        )

    angle_key, _, _ = losa.find_hdf_key(file_path, "rotation")
    for key in angle_key:
        print("Key having the 'rotation' pattern :-> {0}".format(key))

    list_key, list_shape, _ = losa.find_hdf_key(file_path, "data")
    for i, key in enumerate(list_key):
        # There're datasets with keys containing "data", we only choose a 3D array.
        if len(list_shape[i]) == 3:
            data_key = key
            break

    image_key = losa.find_hdf_key(file_path, "image_key")[0][0]

    ikey = np.squeeze(np.asarray(losa.load_hdf(file_path, image_key)))
    angles = np.squeeze(np.asarray(losa.load_hdf(file_path, angle_key)))
    data = losa.load_hdf(file_path, data_key)  # This is an object not ndarray.

    (depth, height, width) = data.shape

    dark_field = np.mean(
        np.asarray(data[np.squeeze(np.where(ikey == 2.0)), :, :]), axis=0
    )
    flat_field = np.mean(
        np.asarray(data[np.squeeze(np.where(ikey == 1.0)), :, :]), axis=0
    )

    proj_idx = np.squeeze(np.where(ikey == 0))
    proj_corr = corr.flat_field_correction(
        data[proj_idx[0], 10:, :], flat_field[10:], dark_field[10:]
    )

    index = height // 2  # Index of a sinogram.
    sinogram = corr.flat_field_correction(
        data[proj_idx[0] : proj_idx[-1], index, :],
        flat_field[index, :],
        dark_field[index, :],
    )

    center = calc.find_center_vo(sinogram)
    print("Center-of-rotation is {}".format(center))
    thetas = angles[proj_idx[0] : proj_idx[-1]] * np.pi / 180
    # # DFI method, a built-in function:
    start_slice = 500
    stop_slice = 750

    print("5 -> Perform reconstruction without artifact removal methods")
    if data_type == "no-ring":
        # Options to include removal methods in the flat-field correction step.
        opt1 = {"method": "remove_zinger", "para1": 0.08, "para2": 1}
        opt2 = {"method": "remove_all_stripe", "para1": 3.0, "para2": 51, "para3": 17}
        # Load sinograms, and perform pre-processing.
        sinograms = corr.flat_field_correction(
            data[proj_idx[0] : proj_idx[-1], start_slice:stop_slice, :],
            flat_field[start_slice:stop_slice, :],
            dark_field[start_slice:stop_slice, :],
            option1=opt1,
            option2=opt2,
        )
        # Perform reconstruction
        print("9 -> Perform reconstruction on this chunk in parallel...")
        recon_img = util.parallel_process_slices(
            sinograms, rec.dfi_reconstruction, [center]
        )
        for i in range(start_slice, stop_slice):
            name = "0000" + str(i)
            losa.save_image(
                rec_dir + "/rec_" + name[-5:] + ".tiff",
                recon_img[:, i - start_slice, :],
            )
        print("!!! Done !!!")

    elif data_type == "with-ring":
        opt1 = None
        opt2 = None
        sinograms = corr.flat_field_correction(
            data[proj_idx[0] : proj_idx[-1], start_slice:stop_slice, :],
            flat_field[start_slice:stop_slice, :],
            dark_field[start_slice:stop_slice, :],
            option1=opt1,
            option2=opt2,
        )

        recon_img = util.parallel_process_slices(
            sinograms, rec.dfi_reconstruction, [center]
        )
        for i in range(start_slice, stop_slice):
            name = "0000" + str(i)
            losa.save_image(
                rec_dir + "/rec_" + name[-5:] + ".tiff",
                recon_img[:, i - start_slice, :],
            )
        print("!!! Done !!!")

    elif data_type == "bad-center":
        opt1 = None
        opt2 = None

        center = pixel_offset(center)

        sinograms = corr.flat_field_correction(
            data[proj_idx[0] : proj_idx[-1], start_slice:stop_slice, :],
            flat_field[start_slice:stop_slice, :],
            dark_field[start_slice:stop_slice, :],
            option1=opt1,
            option2=opt2,
        )

        recon_img = util.parallel_process_slices(
            sinograms, rec.dfi_reconstruction, [center]
        )
        for i in range(start_slice, stop_slice):
            name = "0000" + str(i)
            losa.save_image(
                rec_dir + "/rec_" + name[-5:] + ".tiff",
                recon_img[:, i - start_slice, :],
            )
        print("!!! Done !!!")

    else:
        print("Invalid stripe method")


def run_reconstruction(directory, data_type) -> None:
    """
    Run reconstruction on all .h5 and nxs files in a directory.
    Args:
        directory (str): The directory containing the .h5 and nxs files.
        data_type (str): The type for reconstruction to generate artifacts.
                    currently supports:
                    with-ring : artifacts generated by keeping ring artifacts(without correction method).
                    no-ring : artifacts generated by removing ring artifacts(fw correction method).
                    bad-center : artifacts generated by providing a wrong center of rotation.

    """
    all_files = os.listdir(directory)

    # Separate .h5 and (hdfs, nxs) files
    h5_files = [f for f in all_files if f.endswith(".h5")]
    other_files = [f for f in all_files if f.endswith((".nxs"))]

    total_files = len(h5_files) + len(other_files)
    print(f"Total number of files: {total_files}")
    print(f"Number of .h5 files: {len(h5_files)}")
    print(f"Number of (hdfs, nxs) files: {len(other_files)}")

    with tqdm(total=total_files) as pbar:
        # Prepare file paths for .h5 files
        h5_files_to_reconstruct = [os.path.join(directory, f) for f in h5_files]
        other_files_to_process = [os.path.join(directory, f) for f in other_files]

        print(h5_files_to_reconstruct)
        print(other_files_to_process)

        with ThreadPoolExecutor(max_workers=2) as executor:
            # Submit reconstruction tasks for .h5 files
            h5_futures = [
                executor.submit(run_reconstruction_file, file_path, data_type)
                for file_path in h5_files_to_reconstruct
            ]

            # Submit algorithm tasks for (hdfs, nxs) files
            other_futures = [
                executor.submit(run_algotom, file_path, data_type)
                for file_path in other_files_to_process
            ]

            # Combine futures and update progress bar as they complete
            all_futures = h5_futures + other_futures
            for future in as_completed(all_futures):
                future.result()  # To raise exceptions if any
                pbar.update(1)


def copy_tiff_file(src_path, dest_path, file, dest_directory):
    shutil.copy(src_path, dest_path)
    print(f"Copied {file} to {dest_directory} as {os.path.basename(dest_path)}")


def copy_tiff_files(src_directory, dest_directory):
    print("destination ", dest_directory)
    os.makedirs(dest_directory, exist_ok=True)
    # src_directory = src_directory + "_rec"
    files_to_copy = []
    for root, _, files in os.walk(src_directory):
        for file in files:
            if file.endswith(".tiff"):
                src_path = os.path.join(root, file)
                parent_dir_name = os.path.basename(root)
                dest_dir_name = os.path.basename(dest_directory)
                new_file_name = f"{dest_dir_name}_{parent_dir_name}_{file}"
                dest_path = os.path.join(dest_directory, new_file_name)
                files_to_copy.append((src_path, dest_path, file))

    with ThreadPoolExecutor() as executor:
        futures = [
            executor.submit(copy_tiff_file, src_path, dest_path, file, dest_directory)
            for src_path, dest_path, file in files_to_copy
        ]
        for future in as_completed(futures):
            future.result()  # To raise exceptions if any


if __name__ == "__main__":
    parser = argparse.ArgumentParser(
        description="Run reconstruction on all .h5 files in a directory."
    )
    parser.add_argument(
        "--directory", type=str, help="The directory containing the .h5 files."
    )

    # Add the arguments
    parser.add_argument(
        "--data-type",
        choices=["with-ring", "no-ring", "bad-center"],
        nargs="?",
        default="with-ring",
        help="Choose one of the available options to generate data : with-ring( default ), no-ring, or bad-center.",
    )

    args = parser.parse_args()

    # Handle the options
    if args.data_type == "with-ring":
        file_name = "datasets-with-ring"
        print(file_name)
    elif args.data_type == "no-ring":
        file_name = "datasets-no-ring"
        print(file_name)
    elif args.data_type == "bad-center":
        file_name = "bad-center"
        print(file_name)
    else:
        print("Invalid option")

    run_reconstruction(args.directory, args.data_type)

    # Define the destination directory
    datasets_directory = os.path.join(args.directory + "_rec", file_name)
    # Copy the .tiff files to the datasets directory
    copy_tiff_files(args.directory, datasets_directory)
